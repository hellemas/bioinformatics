
# Phylogenetics

> Tree-Based Analysis of Evolutionary Relationships

Phylogenetics represents one of the most fundamental disciplines in modern biology, providing the mathematical and computational framework for understanding the evolutionary relationships among organisms. At its core, phylogenetics seeks to reconstruct the tree of life—the branching pattern of descent that connects all living things through their shared evolutionary history. This field combines elements from evolutionary biology, mathematics, statistics, and computer science to infer these relationships from molecular and morphological data. The importance of phylogenetic analysis extends far beyond academic curiosity; it plays crucial roles in understanding disease evolution, tracking pandemic spread, conservation biology, drug discovery, and our fundamental understanding of life's diversity.

The modern era of phylogenetics began with the molecular revolution, when scientists gained the ability to sequence DNA and proteins. This molecular data provides a rich source of information about evolutionary relationships, as mutations accumulate over time in a roughly clock-like fashion. By comparing sequences from different organisms, we can infer their evolutionary relationships and estimate the time since they diverged from common ancestors. However, this inference is not straightforward—it requires sophisticated mathematical models and computational algorithms to account for the complex processes of molecular evolution.

Phylogenetic trees, also known as evolutionary trees or cladograms, are the primary tools for representing evolutionary relationships. These trees consist of nodes connected by branches, where the leaves (terminal nodes) represent contemporary species or sequences, internal nodes represent hypothetical common ancestors, and branches represent the evolutionary paths connecting them. The topology of the tree—its branching pattern—encodes the relationships among organisms, while branch lengths often represent evolutionary time or the amount of evolutionary change.

The computational challenges in phylogenetics are substantial. For even a modest number of species, the number of possible tree topologies is astronomical. For instance, with just 10 species, there are over 34 million possible unrooted trees. This number grows super-exponentially with the number of taxa, making exhaustive searches impossible for datasets of realistic size. Consequently, phylogenetic inference relies heavily on clever algorithms, heuristic searches, and statistical approaches to navigate this vast space of possible trees.

This lecture note explores two fundamental aspects of computational phylogenetics. First, we examine the principle of recursion and its application to tree algorithms, demonstrating how recursive thinking naturally aligns with the hierarchical structure of phylogenetic trees. Second, we delve into the Felsenstein pruning algorithm, a cornerstone method for calculating the likelihood of sequence data given a phylogenetic tree. Together, these topics provide essential foundations for understanding modern phylogenetic analysis.

# Part I: Recursion and Tree Algorithms in Phylogenetics

## The Principle of Recursion  {.unnumbered}

Recursion is a programming paradigm where a function calls itself to solve smaller instances of the same problem. This approach is particularly elegant for problems that exhibit self-similar structure, where the solution to a larger problem can be expressed in terms of solutions to smaller, similar subproblems. In phylogenetics, trees are inherently recursive structures—each subtree is itself a complete tree with the same structural properties as the whole. This makes recursion the natural choice for implementing tree algorithms.

The key to understanding recursion lies in recognizing two essential components: the base case and the recursive case. The base case defines the simplest version of the problem that can be solved directly without further recursion. The recursive case breaks down the problem into smaller subproblems and combines their solutions. Without a proper base case, recursion would continue indefinitely, leading to stack overflow errors.

In Python, recursive functions follow a standard pattern:

```python
def recursive_function(input):
    # Base case: check if we've reached the simplest form
    if is_base_case(input):
        return base_case_solution(input)

    # Recursive case: break down the problem
    smaller_problems = decompose(input)

    # Solve smaller problems recursively
    solutions = [recursive_function(problem) for problem in smaller_problems]

    # Combine solutions
    return combine_solutions(solutions)
```

This pattern appears repeatedly in phylogenetic algorithms. Trees naturally decompose into subtrees rooted at child nodes, making recursive algorithms both intuitive and efficient for tree-based computations.

## Tree Representation in Python  {.unnumbered}

Before implementing recursive algorithms on phylogenetic trees, we need a suitable data structure to represent trees in Python. A simple yet effective approach uses nested dictionaries or custom classes. Here's a basic tree node class that supports phylogenetic computations:

```python
class TreeNode:
    def __init__(self, name=None, branch_length=0.0):
        self.name = name  # Species name for leaves, None for internal nodes
        self.branch_length = branch_length  # Length of branch leading to this node
        self.children = []  # List of child nodes
        self.parent = None  # Reference to parent node

    def add_child(self, child):
        """Add a child node to this node"""
        self.children.append(child)
        child.parent = self

    def is_leaf(self):
        """Check if this node is a leaf (has no children)"""
        return len(self.children) == 0

    def is_root(self):
        """Check if this node is the root (has no parent)"""
        return self.parent is None
```

This representation allows us to build trees programmatically and traverse them using recursive algorithms. For example, we can construct a simple phylogenetic tree:

```python
# Create a simple tree: ((A,B),C)
root = TreeNode()
left_child = TreeNode()
right_child = TreeNode(name="C", branch_length=0.5)

leaf_a = TreeNode(name="A", branch_length=0.3)
leaf_b = TreeNode(name="B", branch_length=0.4)

root.add_child(left_child)
root.add_child(right_child)
left_child.add_child(leaf_a)
left_child.add_child(leaf_b)
```

## Counting Leaves: A Simple Recursive Algorithm  {.unnumbered}

One of the simplest recursive algorithms on trees counts the number of leaves (terminal nodes). This algorithm demonstrates the elegance of recursive thinking for tree problems:

```python
def count_leaves(node):
    """
    Recursively count the number of leaves in a tree.

    Parameters:
    node: TreeNode - The root of the tree or subtree

    Returns:
    int - The number of leaves in the tree
    """
    # Base case: if this is a leaf, return 1
    if node.is_leaf():
        return 1

    # Recursive case: sum the leaves in all subtrees
    total_leaves = 0
    for child in node.children:
        total_leaves += count_leaves(child)

    return total_leaves
```

The algorithm works by checking if the current node is a leaf. If it is, we've found one leaf and return 1. Otherwise, we recursively count the leaves in each subtree and sum the results. This naturally handles trees of any size and shape.

We can also write this more concisely using Python's sum function and a generator expression:

```python
def count_leaves_compact(node):
    """Compact version of leaf counting"""
    if node.is_leaf():
        return 1
    return sum(count_leaves_compact(child) for child in node.children)
```

## Calculating Tree Height  {.unnumbered}

Another fundamental recursive algorithm calculates the height (or depth) of a tree—the maximum distance from the root to any leaf:

```python
def tree_height(node):
    """
    Calculate the height of a tree (maximum depth).

    Parameters:
    node: TreeNode - The root of the tree

    Returns:
    int - The height of the tree
    """
    # Base case: a leaf has height 0
    if node.is_leaf():
        return 0

    # Recursive case: height is 1 plus maximum height of children
    max_child_height = max(tree_height(child) for child in node.children)
    return 1 + max_child_height
```

This algorithm demonstrates how recursion naturally handles the branching structure of trees. Each recursive call explores one branch, and the max function ensures we find the longest path from root to leaf.

## Collecting Species Names  {.unnumbered}

In phylogenetic analysis, we often need to collect all species names (leaf labels) in a tree. This is another natural application of recursion:

```python
def get_species_names(node):
    """
    Recursively collect all species names in a tree.

    Parameters:
    node: TreeNode - The root of the tree

    Returns:
    list - A list of all species names
    """
    # Base case: if this is a leaf, return its name
    if node.is_leaf():
        return [node.name] if node.name else []

    # Recursive case: collect names from all subtrees
    all_names = []
    for child in node.children:
        all_names.extend(get_species_names(child))

    return all_names
```

## Tree Traversal Strategies  {.unnumbered}

Tree traversal—visiting all nodes in a tree systematically—is fundamental to many phylogenetic algorithms. There are several traversal strategies, each suited to different tasks:

### Pre-order Traversal  {.unnumbered}

In pre-order traversal, we visit the current node before visiting its children:

```python
def preorder_traversal(node, visit_function):
    """
    Perform pre-order traversal of a tree.

    Parameters:
    node: TreeNode - The current node
    visit_function: function - Function to apply to each node
    """
    # Visit current node first
    visit_function(node)

    # Then visit all children
    for child in node.children:
        preorder_traversal(child, visit_function)
```

Pre-order traversal is useful when we need to process parent nodes before their children, such as when propagating information down the tree.

### Post-order Traversal  {.unnumbered}

In post-order traversal, we visit children before the parent:

```python
def postorder_traversal(node, visit_function):
    """
    Perform post-order traversal of a tree.

    Parameters:
    node: TreeNode - The current node
    visit_function: function - Function to apply to each node
    """
    # Visit all children first
    for child in node.children:
        postorder_traversal(child, visit_function)

    # Then visit current node
    visit_function(node)
```

Post-order traversal is crucial for algorithms that need to process children before parents, such as the Felsenstein pruning algorithm we'll discuss later.

## Calculating Total Branch Length  {.unnumbered}

The total branch length of a tree is the sum of all branch lengths, often used as a measure of the amount of evolution:

```python
def total_branch_length(node):
    """
    Calculate the sum of all branch lengths in a tree.

    Parameters:
    node: TreeNode - The root of the tree

    Returns:
    float - The total branch length
    """
    # Start with this node's branch length (0 for root)
    total = node.branch_length if not node.is_root() else 0

    # Add branch lengths from all subtrees
    for child in node.children:
        total += total_branch_length(child)

    return total
```

# Part II: The Felsenstein Pruning Algorithm

## Introduction to Likelihood-Based Phylogenetics  {.unnumbered}

The Felsenstein pruning algorithm, introduced by Joseph Felsenstein in 1981, revolutionized phylogenetic inference by providing an efficient method to calculate the likelihood of observed sequence data given a phylogenetic tree and an evolutionary model. This algorithm forms the foundation of maximum likelihood and Bayesian approaches to phylogenetic inference, which are now the gold standard methods in the field.

The fundamental question addressed by the Felsenstein algorithm is: given a set of aligned DNA or protein sequences and a proposed phylogenetic tree (including topology and branch lengths), what is the probability of observing these sequences under a specified model of evolution? This likelihood calculation is essential for comparing different trees and finding the tree that best explains the observed data.

The key insight of Felsenstein's algorithm is that the likelihood calculation, which would be computationally intractable if done naively, can be performed efficiently using dynamic programming on the tree structure. The algorithm exploits the Markov property of evolutionary models—the idea that evolution along different branches is independent given the ancestral states—to break down the calculation into manageable pieces.

## Mathematical Foundation  {.unnumbered}

Consider a phylogenetic tree $T$ with $n$ leaves (observed sequences) and a set of aligned sequences at a single site. Let the observed nucleotides at this site be denoted as $D = \{d_1, d_2, ..., d_n\}$, where each $d_i \in \{A, C, G, T\}$ for DNA sequences.

The likelihood of the data at this site given the tree is:

$$L(D|T, \theta) = \sum_{r \in \{A,C,G,T\}} \pi_r P(D|r, T, \theta)$$

where:
- $\pi_r$ is the equilibrium frequency of nucleotide $r$ at the root
- $P(D|r, T, \theta)$ is the probability of observing data $D$ given root state $r$
- $\theta$ represents the model parameters (substitution rates, etc.)

The challenge is computing $P(D|r, T, \theta)$ efficiently. This requires summing over all possible internal node states, which grows exponentially with the number of internal nodes.

## The Substitution Model  {.unnumbered}

The Felsenstein algorithm requires a model of sequence evolution. The simplest model is the Jukes-Cantor (JC69) model, which assumes:
- Equal base frequencies: $\pi_A = \pi_C = \pi_G = \pi_T = 0.25$
- Equal substitution rates between all pairs of nucleotides

Under the JC69 model, the probability of observing nucleotide $j$ given ancestral nucleotide $i$ after evolutionary time $t$ is:

$$P_{ij}(t) = \begin{cases}
\frac{1}{4} + \frac{3}{4}e^{-\frac{4\mu t}{3}} & \text{if } i = j \\
\frac{1}{4} - \frac{1}{4}e^{-\frac{4\mu t}{3}} & \text{if } i \neq j
\end{cases}$$

where $\mu$ is the substitution rate.

More complex models like the General Time Reversible (GTR) model allow for different substitution rates and base frequencies, but the principle remains the same.

## The Pruning Algorithm  {.unnumbered}

The Felsenstein pruning algorithm uses post-order traversal to compute partial likelihoods from the leaves up to the root. For each node and each possible state, it computes the likelihood of the subtree below that node.

Let $L_k(i)$ denote the partial likelihood at node $k$ for state $i$—the probability of observing all the sequence data in the subtree rooted at $k$, given that node $k$ has state $i$.

For a leaf node $k$ with observed state $d_k$:
$$L_k(i) = \begin{cases}
1 & \text{if } i = d_k \\
0 & \text{if } i \neq d_k
\end{cases}$$

For an internal node $k$ with children $m$ and $n$:
$$L_k(i) = \left(\sum_{j} P_{ij}(t_m) L_m(j)\right) \times \left(\sum_{j} P_{ij}(t_n) L_n(j)\right)$$

where $t_m$ and $t_n$ are the branch lengths leading to children $m$ and $n$, respectively.

## Python Implementation  {.unnumbered}

Here's a complete implementation of the Felsenstein pruning algorithm:

```python
import numpy as np
from math import exp

class FelsensteinCalculator:
    def __init__(self, substitution_model='JC69'):
        """
        Initialize the Felsenstein likelihood calculator.

        Parameters:
        substitution_model: str - The substitution model to use
        """
        self.model = substitution_model
        self.states = ['A', 'C', 'G', 'T']
        self.state_to_index = {state: i for i, state in enumerate(self.states)}

        # Set equilibrium frequencies based on model
        if self.model == 'JC69':
            self.pi = np.array([0.25, 0.25, 0.25, 0.25])
            self.mu = 1.0  # Substitution rate

    def transition_probability(self, branch_length):
        """
        Calculate transition probability matrix for given branch length.

        Parameters:
        branch_length: float - The branch length

        Returns:
        numpy.ndarray - 4x4 transition probability matrix
        """
        if self.model == 'JC69':
            # Jukes-Cantor transition probabilities
            p_same = 0.25 + 0.75 * exp(-4.0 * self.mu * branch_length / 3.0)
            p_diff = 0.25 - 0.25 * exp(-4.0 * self.mu * branch_length / 3.0)

            P = np.full((4, 4), p_diff)
            np.fill_diagonal(P, p_same)
            return P
        else:
            raise NotImplementedError(f"Model {self.model} not implemented")

    def initialize_leaf_likelihood(self, observed_state):
        """
        Initialize likelihood vector for a leaf node.

        Parameters:
        observed_state: str - The observed nucleotide at this leaf

        Returns:
        numpy.ndarray - Likelihood vector
        """
        likelihood = np.zeros(4)
        if observed_state in self.state_to_index:
            likelihood[self.state_to_index[observed_state]] = 1.0
        else:
            # Handle ambiguous characters or gaps
            likelihood[:] = 1.0  # All states equally likely

        return likelihood

    def calculate_internal_likelihood(self, node, child_likelihoods):
        """
        Calculate likelihood vector for an internal node.

        Parameters:
        node: TreeNode - The internal node
        child_likelihoods: list - List of (child_node, likelihood_vector) tuples

        Returns:
        numpy.ndarray - Likelihood vector for this node
        """
        node_likelihood = np.ones(4)

        for child, child_like in child_likelihoods:
            # Get transition probability matrix for this branch
            P = self.transition_probability(child.branch_length)

            # Calculate contribution from this child
            contribution = P.dot(child_like)

            # Multiply contributions from all children
            node_likelihood *= contribution

        return node_likelihood

    def calculate_site_likelihood(self, tree_root, site_data):
        """
        Calculate likelihood for a single site using Felsenstein pruning.

        Parameters:
        tree_root: TreeNode - Root of the phylogenetic tree
        site_data: dict - Dictionary mapping species names to nucleotides

        Returns:
        float - Log-likelihood for this site
        """
        # First pass: post-order traversal to compute partial likelihoods
        likelihoods = {}

        def compute_likelihood(node):
            if node.is_leaf():
                # Initialize leaf likelihood
                observed = site_data.get(node.name, 'N')
                likelihoods[node] = self.initialize_leaf_likelihood(observed)
            else:
                # Compute likelihood for internal node
                child_data = []
                for child in node.children:
                    compute_likelihood(child)  # Ensure child is processed
                    child_data.append((child, likelihoods[child]))

                likelihoods[node] = self.calculate_internal_likelihood(
                    node, child_data
                )

        # Compute all partial likelihoods
        compute_likelihood(tree_root)

        # Calculate final likelihood at root
        root_likelihood = likelihoods[tree_root]
        site_likelihood = np.dot(self.pi, root_likelihood)

        # Return log-likelihood to avoid underflow
        return np.log(site_likelihood) if site_likelihood > 0 else float('-inf')

    def calculate_total_likelihood(self, tree_root, alignment):
        """
        Calculate total likelihood for an alignment.

        Parameters:
        tree_root: TreeNode - Root of the phylogenetic tree
        alignment: dict - Dictionary mapping species names to sequences

        Returns:
        float - Total log-likelihood
        """
        # Get sequence length (assume all sequences same length)
        seq_length = len(next(iter(alignment.values())))

        total_log_likelihood = 0.0

        # Calculate likelihood for each site
        for site_idx in range(seq_length):
            # Extract nucleotides at this site
            site_data = {
                species: seq[site_idx]
                for species, seq in alignment.items()
            }

            # Add log-likelihood for this site
            site_log_like = self.calculate_site_likelihood(tree_root, site_data)
            total_log_likelihood += site_log_like

        return total_log_likelihood
```

## Handling Numerical Underflow  {.unnumbered}

One practical challenge in implementing the Felsenstein algorithm is numerical underflow. As we multiply many small probabilities together, the values can become too small to represent in floating-point arithmetic. There are several strategies to address this:

### Scaling Method  {.unnumbered}

The scaling method maintains the relative proportions of partial likelihoods while keeping values in a reasonable range:

```python
def calculate_internal_likelihood_scaled(self, node, child_likelihoods):
    """
    Calculate likelihood with scaling to prevent underflow.
    """
    node_likelihood = np.ones(4)
    scale_factors = []

    for child, child_like in child_likelihoods:
        P = self.transition_probability(child.branch_length)
        contribution = P.dot(child_like)

        # Scale to prevent underflow
        max_contrib = np.max(contribution)
        if max_contrib > 0:
            contribution /= max_contrib
            scale_factors.append(np.log(max_contrib))

        node_likelihood *= contribution

    # Store scale factor for this node
    self.scale_factors[node] = sum(scale_factors)

    return node_likelihood
```

### Log-Likelihood Method  {.unnumbered}

An alternative is to work entirely in log space:

```python
def calculate_log_likelihood(self, node, child_log_likelihoods):
    """
    Calculate log-likelihood to avoid underflow.
    """
    log_likelihood = np.zeros(4)

    for state_parent in range(4):
        log_sum = 0.0

        for child, child_log_like in child_log_likelihoods:
            P = self.transition_probability(child.branch_length)

            # Use log-sum-exp trick for numerical stability
            terms = []
            for state_child in range(4):
                if P[state_parent, state_child] > 0:
                    terms.append(
                        np.log(P[state_parent, state_child]) +
                        child_log_like[state_child]
                    )

            log_sum += self.log_sum_exp(terms)

        log_likelihood[state_parent] = log_sum

    return log_likelihood

def log_sum_exp(self, log_values):
    """
    Compute log(sum(exp(log_values))) in a numerically stable way.
    """
    max_val = max(log_values)
    return max_val + np.log(sum(exp(val - max_val) for val in log_values))
```

## Practical Example: Analyzing a Small Alignment  {.unnumbered}

Let's work through a complete example of using the Felsenstein algorithm on a small dataset:

```python
def example_analysis():
    """
    Complete example of phylogenetic likelihood calculation.
    """
    # Create a simple tree: ((Human, Chimp), (Mouse, Rat))
    root = TreeNode()
    primates = TreeNode(branch_length=0.1)
    rodents = TreeNode(branch_length=0.15)

    human = TreeNode(name="Human", branch_length=0.05)
    chimp = TreeNode(name="Chimp", branch_length=0.06)
    mouse = TreeNode(name="Mouse", branch_length=0.2)
    rat = TreeNode(name="Rat", branch_length=0.18)

    root.add_child(primates)
    root.add_child(rodents)
    primates.add_child(human)
    primates.add_child(chimp)
    rodents.add_child(mouse)
    rodents.add_child(rat)

    # Sample alignment (5 sites)
    alignment = {
        "Human": "ACGTG",
        "Chimp": "ACGTA",
        "Mouse": "CCATA",
        "Rat":   "CCGTA"
    }

    # Calculate likelihood
    calc = FelsensteinCalculator()
    log_likelihood = calc.calculate_total_likelihood(root, alignment)

    print(f"Tree: ((Human:{human.branch_length}, Chimp:{chimp.branch_length}), "
          f"(Mouse:{mouse.branch_length}, Rat:{rat.branch_length}))")
    print(f"Alignment length: {len(alignment['Human'])} sites")
    print(f"Log-likelihood: {log_likelihood:.4f}")
    print(f"Likelihood: {exp(log_likelihood):.6e}")

    # Analyze each site
    for site_idx in range(len(alignment['Human'])):
        site_data = {
            species: seq[site_idx]
            for species, seq in alignment.items()
        }
        site_log_like = calc.calculate_site_likelihood(root, site_data)
        print(f"Site {site_idx + 1}: {' '.join(site_data.values())} -> "
              f"Log-likelihood: {site_log_like:.4f}")

    return root, alignment, log_likelihood

# Run the example
tree, align, log_like = example_analysis()
```

## Optimizing Branch Lengths  {.unnumbered}

The Felsenstein algorithm is often used within an optimization framework to find the branch lengths that maximize the likelihood:

```python
from scipy.optimize import minimize

def optimize_branch_lengths(tree_root, alignment, initial_lengths=None):
    """
    Optimize branch lengths to maximize likelihood.

    Parameters:
    tree_root: TreeNode - Root of the tree
    alignment: dict - Sequence alignment
    initial_lengths: list - Initial branch length values

    Returns:
    list - Optimized branch lengths
    """
    calc = FelsensteinCalculator()

    # Collect all branches
    branches = []
    def collect_branches(node):
        if not node.is_root():
            branches.append(node)
        for child in node.children:
            collect_branches(child)

    collect_branches(tree_root)

    # Set initial lengths
    if initial_lengths is None:
        initial_lengths = [0.1] * len(branches)

    def objective(lengths):
        # Update branch lengths
        for branch, length in zip(branches, lengths):
            branch.branch_length = length

        # Calculate negative log-likelihood (for minimization)
        log_like = calc.calculate_total_likelihood(tree_root, alignment)
        return -log_like

    # Optimize with bounds (lengths must be positive)
    result = minimize(
        objective,
        initial_lengths,
        method='L-BFGS-B',
        bounds=[(1e-6, 10.0)] * len(branches)
    )

    # Update tree with optimized lengths
    for branch, length in zip(branches, result.x):
        branch.branch_length = length

    return result.x, -result.fun
```

## Applications and Extensions  {.unnumbered}

The Felsenstein algorithm has numerous applications and extensions in modern phylogenetics:

### Rate Heterogeneity  {.unnumbered}

Real sequences evolve at different rates at different sites. The gamma distribution is commonly used to model rate heterogeneity across sites, allowing some positions to evolve faster or slower than others. This is implemented by calculating the likelihood under different rate categories and averaging them according to the gamma distribution.

### Ancestral State Reconstruction  {.unnumbered}

The partial likelihoods computed during the Felsenstein algorithm can be used to reconstruct the most likely ancestral sequences at internal nodes of the tree. This involves a second pass through the tree, using the partial likelihoods to compute posterior probabilities of each state at each internal node.

### Model Selection  {.unnumbered}

The Felsenstein algorithm enables comparison of different substitution models through likelihood ratio tests or information criteria like AIC and BIC. By calculating likelihoods under different models, we can determine which model best explains the observed data while accounting for model complexity.

## Computational Complexity and Performance  {.unnumbered}

The time complexity of the Felsenstein algorithm is $O(n \times m \times s^2)$, where:
- $n$ is the number of nodes in the tree
- $m$ is the sequence length
- $s$ is the number of states (4 for DNA, 20 for proteins)

The space complexity is $O(n \times s)$ for storing partial likelihoods at each node.

For large-scale analyses, several optimizations are crucial:
- **Site pattern compression**: Many sites may have identical patterns across species, so we can compute the likelihood once per pattern and weight by frequency
- **Parallelization**: Sites are independent, allowing parallel computation across multiple processors
- **Vectorization**: Modern CPUs can process multiple likelihood calculations simultaneously using SIMD instructions
- **GPU acceleration**: The matrix operations in the Felsenstein algorithm are well-suited for GPU computation

## Integration with Tree Search  {.unnumbered}

The Felsenstein algorithm is typically embedded within tree search algorithms that explore the space of possible topologies:

```python
def hill_climbing_tree_search(alignment, starting_tree):
    """
    Simple hill-climbing search for the best tree.
    """
    calc = FelsensteinCalculator()
    current_tree = starting_tree
    current_likelihood = calc.calculate_total_likelihood(current_tree, alignment)

    improved = True
    while improved:
        improved = False

        # Try all possible NNI moves
        for move in generate_nni_moves(current_tree):
            # Apply move
            modified_tree = apply_nni(current_tree, move)

            # Optimize branch lengths
            optimized_lengths, new_likelihood = optimize_branch_lengths(
                modified_tree, alignment
            )

            # Accept if better
            if new_likelihood > current_likelihood:
                current_tree = modified_tree
                current_likelihood = new_likelihood
                improved = True
                break

    return current_tree, current_likelihood
```

## Conclusion  {.unnumbered}

The combination of recursive algorithms and the Felsenstein pruning algorithm provides a powerful framework for phylogenetic analysis. Recursion naturally captures the hierarchical structure of evolutionary trees, enabling elegant and efficient implementations of tree algorithms. The Felsenstein algorithm, by efficiently calculating likelihoods through dynamic programming on trees, makes statistical phylogenetic inference computationally feasible even for large datasets.

These methods have revolutionized our understanding of evolution, from reconstructing the tree of life to tracking disease outbreaks. The recursive algorithms we explored—from simple leaf counting to complex traversal strategies—demonstrate how recursive thinking aligns perfectly with the hierarchical nature of phylogenetic trees. The Felsenstein algorithm showcases how clever algorithmic design can make seemingly intractable calculations feasible, enabling us to extract evolutionary signal from molecular sequences.

The principles covered in this lecture—recursive thinking for tree problems and likelihood-based inference—extend beyond phylogenetics to many areas of computational biology and computer science. Understanding these concepts provides a foundation for tackling complex problems involving hierarchical data and probabilistic inference. As sequencing technologies continue to advance and datasets grow ever larger, these fundamental algorithms remain at the heart of phylogenetic analysis, adapted and extended to meet new challenges but retaining their essential elegance and power.

The beauty of phylogenetic algorithms lies in their ability to reveal the hidden history written in DNA and proteins. Through recursive algorithms and statistical models like the Felsenstein algorithm, we can read this molecular record and understand the processes that have shaped life on Earth over billions of years. This synthesis of mathematics, computer science, and biology exemplifies the power of interdisciplinary approaches in modern science, providing tools that continue to yield new insights into the nature and history of life.
